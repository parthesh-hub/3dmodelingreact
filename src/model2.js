/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

// The basic layout of this file which is by the way different for every model can be generated by using gltfjsx module. 
// It converts the .glb file of model(exported from blender) into the .js file. 
// Further .js file is then modified as per the requirements. Like adding states/ functionalities.


import React, { useRef, useState, useEffect } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import * as THREE from 'three';
import mqtt from 'mqtt/dist/mqtt';

var client  = mqtt.connect('ws://yourherokuappname.herokuapp.com') // heroku app where MQTT server is hosted.


client.on('connect', function () {
  client.subscribe('Sensor') // publish data from IMU sensors to the topic name - "Sensor"
})


export default function Model({ ...props }) {

  const group = useRef()
  const { nodes, materials } = useGLTF('/model2.glb')

  
  // 'data' state used to rerender the model everytime new data gets updated at broker.

  const [data, setData] = useState({
    lfarmx : 0, lfarmy : 0, lfarmz : 0, lfarmw : 1,
    lshx : 0, lshy : 0, lshz : 0, lshw : 1,
    rarmx : 0, rarmy : 0, rarmz : 0, rarmw : 1,
    rshx : 0, rshy : 0 , rshz : 0, rshw : 1,
    lflegx : 0, lflegy : 0, lflegz : 0, lflegw : 1,
    lfuplegx : 0, lfuplegy : 0, lfuplegz : 0 , lfuplegw : 1,
    rlegx : 0, rlegy : 0, rlegz : 0, rlegw : 1,
    ruplegx : 0, ruplegy :0, ruplegz:0, ruplegw : 1,
    headx : 0, heady :0, headz: 0, headw : 1,
    wax :0, way:0, waz:0, waw:1

  });



// UseEffect inorder to subscribe the topic at broker
  useEffect(() => {

    client.on('message', function (topic, message) {
    
      setData((prevState) => ({
        ...prevState,
        ...JSON.parse(message.toString())
      }))

    })
    
  }, []);


// Initial quaternion values of the bones/joints need to be added to the sensor data, inorder to keep model in T-Pose.
// These added values can be found under quaternion sections of each bone. 
// These quaternion data for every joint can be obtained by performing --> console.log(nodes) 

// In some parts one axis value is assigned to another axis quaternion and sometimes negation is performed, 
// it is all because of the position of sensors applied on the body. 


// //1 - LeftForeArm
    nodes.mixamorig1LeftForeArm.quaternion._x = (-parseFloat(data.lfarmx)+1.0915051262827546e-7);
    nodes.mixamorig1LeftForeArm.quaternion._y= (parseFloat(data.lfarmy)-0.002788124606013298);
    nodes.mixamorig1LeftForeArm.quaternion._z = (-parseFloat(data.lfarmz)-6.18749709246913e-8);
    nodes.mixamorig1LeftForeArm.quaternion._w = parseFloat(data.lfarmw)-1+0.9999961256980896;

  
// //2 - LeftArm
    nodes.mixamorig1LeftArm.quaternion._x = (-parseFloat(data.lshx)-0.1298428773880005);
    nodes.mixamorig1LeftArm.quaternion._y= (parseFloat(data.lshy)+0.005036490969359875);
    nodes.mixamorig1LeftArm.quaternion._z = (-parseFloat(data.lshz)+0.01805739477276802);
    nodes.mixamorig1LeftArm.quaternion._w = parseFloat(data.lshw)-1+0.9913573265075684;


// //3 RightForeArm
     nodes.mixamorig1RightForeArm.quaternion._x = (parseFloat(data.rarmx)-2.9736536788504964e-8);
     nodes.mixamorig1RightForeArm.quaternion._y= (-parseFloat(data.rarmy)+ 0.002874879166483879);
     nodes.mixamorig1RightForeArm.quaternion._z = (-parseFloat(data.rarmz)-3.5882263205166964e-7);
     nodes.mixamorig1RightForeArm.quaternion._w = parseFloat(data.rarmw)-1+0.9999958872795105;


// // 4 - RightArm
     nodes.mixamorig1RightArm.quaternion._x = (parseFloat(data.rshx)-0.13042263686656952);
     nodes.mixamorig1RightArm.quaternion._y= (-parseFloat(data.rshy)-0.006395601201802492);
     nodes.mixamorig1RightArm.quaternion._z = (-parseFloat(data.rshz)-0.013234584592282772);
     nodes.mixamorig1RightArm.quaternion._w = parseFloat(data.rshw)-1+0.9913495182991028;

// //5 - LeftLeg
     
     nodes.mixamorig1LeftLeg.quaternion._x = (-parseFloat(data.lflegy)-0.010350920259952545);
     nodes.mixamorig1LeftLeg.quaternion._y= (-parseFloat(data.lflegz)-0.000052863375458400697);
     nodes.mixamorig1LeftLeg.quaternion._z = (parseFloat(data.lflegx)-0.003967464901506901);
     nodes.mixamorig1LeftLeg.quaternion._w = parseFloat(data.lflegw)-1+0.9999385476112366;


// //6 - LefUpLeg
    const eul1 = new THREE.Euler(parseFloat(data.lfuplegy)+0.02190750839898653,parseFloat(data.lfuplegz)-0.005320303729976244,parseFloat(data.lfuplegx)-3.137722424174463); //this now controls the rotation of the model
    nodes.mixamorig1LeftUpLeg.quaternion.setFromEuler(eul1);



// //7 - RightLeg
     nodes.mixamorig1RightLeg.quaternion._x = (-parseFloat(data.rlegy)-0.009340142831206322);
     nodes.mixamorig1RightLeg.quaternion._y= (-parseFloat(data.rlegz)+0.00004465048550628126);
     nodes.mixamorig1RightLeg.quaternion._z = (parseFloat(data.rlegx)+0.003958456218242645);
     nodes.mixamorig1RightLeg.quaternion._w = parseFloat(data.rlegw)-1+0.9999485611915588;

// //8 - RightUpLeg
    const eul2 = new THREE.Euler(parseFloat(data.ruplegy)+0.02036604437536331,parseFloat(data.ruplegz)+0.004847261403336874,parseFloat(data.ruplegx)+3.137677902749106); 
    nodes.mixamorig1RightUpLeg.quaternion.setFromEuler(eul2);

 
// //9 - Head
     nodes.mixamorig1Head.quaternion._x = (-parseFloat(data.headx)-1.0018079699136706e-9);
     nodes.mixamorig1Head.quaternion._y= (parseFloat(data.headz)-2.168404344971009e-19);
     nodes.mixamorig1Head.quaternion._z = (parseFloat(data.heady)-9.264227374550709e-21);
     nodes.mixamorig1Head.quaternion._w = parseFloat(data.headw)-1+1;

// // 10 - Waist/Spine
    nodes.mixamorig1Spine.quaternion._x = (-parseFloat(data.way)-0.06039626896381378);
    nodes.mixamorig1Spine.quaternion._y= (parseFloat(data.waz)+9.763809885043884e-7);
    nodes.mixamorig1Spine.quaternion._z = (-parseFloat(data.wax)-0.000010212562301603612);
    nodes.mixamorig1Spine.quaternion._w = parseFloat(data.waw)-1+0.9981744885444641;

  
  return (
    <React.Fragment>
    <group ref={group} {...props} dispose={null}>
      <group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
        <primitive object={nodes.mixamorig1Hips} />
        <skinnedMesh geometry={nodes.Ch36.geometry} material={materials.Ch36_Body} skeleton={nodes.Ch36.skeleton} />
      </group>
    </group>
    </React.Fragment>
  )
}

useGLTF.preload('/model2.glb')

